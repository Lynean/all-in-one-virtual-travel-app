import React, { useState, useEffect, useRef } from 'react';
import { Search, Navigation, MapPin, Loader2, Bot, Layers, Crosshair, Trash2, UtensilsCrossed, Hotel, Camera, ShoppingBag, X } from 'lucide-react';
import { loadGoogleMapsScript, createMap, createMarker, createInfoWindow, MapLocation } from '../utils/googleMaps';
import { hybridRouter } from '../services/hybridRouter';
import { useStore } from '../store/useStore';
import { computeRoutes, latLngToLocation, decodePolyline, TravelMode } from '../services/routesApi';
import { searchNearby, searchText, convertLegacyPlaceType, latLngToLocation as placesLatLngToLocation, locationToLatLng } from '../services/placesApi';
import { configService } from '../services/configService';

export const MapView: React.FC = () => {
  const [searchQuery, setSearchQuery] = useState('');
  const [userLocation, setUserLocation] = useState<MapLocation | null>(null);
  const [locationError, setLocationError] = useState<string>('');
  const [isMapLoading, setIsMapLoading] = useState(true);
  const [mapError, setMapError] = useState<string>('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [isScriptLoaded, setIsScriptLoaded] = useState(false);
  const [transitInstructions, setTransitInstructions] = useState<any>(null);
  const [allRoutes, setAllRoutes] = useState<any[]>([]);
  const [selectedRouteIndex, setSelectedRouteIndex] = useState(0);
  const [showNearbyMenu, setShowNearbyMenu] = useState(false);
  
  const mapRef = useRef<HTMLDivElement>(null);
  const mapInstanceRef = useRef<google.maps.Map | null>(null);
  const markersRef = useRef<google.maps.marker.AdvancedMarkerElement[]>([]);
  const userMarkerRef = useRef<google.maps.marker.AdvancedMarkerElement | null>(null);
  const directionsPolylinesRef = useRef<google.maps.Polyline[]>([]);
  
  // Cache for geocoding results to prevent duplicate API calls
  const geocodeCache = useRef<Map<string, MapLocation>>(new Map());
  const pendingGeocodeRequests = useRef<Set<string>>(new Set());
  const lastGeocodingTime = useRef<number>(0);
  const GEOCODING_RATE_LIMIT = 200; // Minimum ms between geocoding requests

  const { 
    destination, 
    currentLocation, 
    setCurrentLocation,
    locationConfirmed,
    setMapInstance 
  } = useStore();

  // Helper function: Calculate distance between two points (Haversine formula)
  const calculateDistance = (point1: { lat: number; lng: number }, point2: { lat: number; lng: number }): number => {
    const R = 6371e3; // Earth's radius in meters
    const œÜ1 = (point1.lat * Math.PI) / 180;
    const œÜ2 = (point2.lat * Math.PI) / 180;
    const ŒîœÜ = ((point2.lat - point1.lat) * Math.PI) / 180;
    const ŒîŒª = ((point2.lng - point1.lng) * Math.PI) / 180;

    const a =
      Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
      Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c; // Distance in meters
  };

  // Step 1: Load Google Maps Script
  useEffect(() => {
    const loadScript = async () => {
      console.log('üó∫Ô∏è Loading Google Maps script...');
      
      try {
        // Get API key from config service (tries backend first, falls back to env)
        const apiKey = await configService.getGoogleMapsApiKey();
        
        console.log('API Key retrieved:', !!apiKey);
        
        if (!apiKey || apiKey === 'undefined') {
          const errorMsg = 'Google Maps API key not configured. Please configure it in the admin panel or add VITE_GOOGLE_MAPS_API_KEY to your .env file.';
          console.error('‚ùå', errorMsg);
          setMapError(errorMsg);
          setIsMapLoading(false);
          return;
        }

        await loadGoogleMapsScript({ apiKey, libraries: ['places', 'geometry', 'marker'] });
        console.log('‚úÖ Google Maps script loaded');
        setIsScriptLoaded(true);
      } catch (error) {
        console.error('‚ùå Failed to load Google Maps:', error);
        setMapError(`Failed to load Google Maps: ${error instanceof Error ? error.message : 'Unknown error'}`);
        setIsMapLoading(false);
      }
    };

    loadScript();
  }, []);

  // Step 2: Create Map Instance when both script and ref are ready
  useEffect(() => {
    console.log('üìç Map creation effect triggered', {
      isScriptLoaded,
      hasMapRef: !!mapRef.current,
      hasMapInstance: !!mapInstanceRef.current
    });

    if (!isScriptLoaded) {
      console.log('‚è≥ Waiting for script to load...');
      return;
    }

    if (!mapRef.current) {
      console.log('‚è≥ Waiting for map ref...');
      // Retry after a short delay
      const timer = setTimeout(() => {
        if (mapRef.current && !mapInstanceRef.current) {
          console.log('üîÑ Retrying map creation...');
          setIsScriptLoaded(prev => prev); // Trigger re-render
        }
      }, 100);
      return () => clearTimeout(timer);
    }

    if (mapInstanceRef.current) {
      console.log('‚ÑπÔ∏è Map instance already exists');
      return;
    }

    console.log('üó∫Ô∏è Creating map instance...');
    
    const initializeMap = async () => {
      try {
        const defaultCenter = { lat: 40.7128, lng: -74.0060 };
        
        // Get Map ID from config service
        const mapId = await configService.getGoogleMapsMapId().catch(() => {
          console.warn('Map ID not configured, using default');
          return undefined;
        });
        
        console.log('Map ID:', mapId || 'not set');
        
        mapInstanceRef.current = createMap(mapRef.current!, defaultCenter, 13, mapId);
        setMapInstance(mapInstanceRef.current);
        setIsMapLoading(false);
        console.log('‚úÖ Map instance created and stored');
      } catch (error) {
        console.error('‚ùå Failed to create map:', error);
        setMapError(`Failed to create map: ${error instanceof Error ? error.message : 'Unknown error'}`);
        setIsMapLoading(false);
      }
    };

    initializeMap();
  }, [isScriptLoaded, setMapInstance]);

  // Helper function to create a blue dot marker for user location
  const createUserLocationMarker = async (map: google.maps.Map, location: MapLocation) => {
    try {
      // Create a blue dot SVG icon
      const blueDotIcon = {
        path: google.maps.SymbolPath.CIRCLE,
        fillColor: '#4285F4',
        fillOpacity: 1,
        strokeColor: '#FFFFFF',
        strokeWeight: 3,
        scale: 10,
      };

      // Create the marker using AdvancedMarkerElement with a custom HTML element
      const markerContent = document.createElement('div');
      markerContent.style.width = '20px';
      markerContent.style.height = '20px';
      markerContent.style.borderRadius = '50%';
      markerContent.style.backgroundColor = '#4285F4';
      markerContent.style.border = '3px solid #FFFFFF';
      markerContent.style.boxShadow = '0 2px 6px rgba(0,0,0,0.3)';
      markerContent.style.cursor = 'pointer';

      const { AdvancedMarkerElement } = await google.maps.importLibrary("marker") as google.maps.MarkerLibrary;
      
      const marker = new AdvancedMarkerElement({
        map,
        position: location,
        content: markerContent,
        title: 'Your Location'
      });

      const infoWindow = createInfoWindow('<strong>You are here</strong>');
      marker.addListener('click', () => {
        infoWindow.open(map, marker);
      });

      return marker;
    } catch (error) {
      console.error('Failed to create user location marker:', error);
      throw error;
    }
  };

  // Function to recalibrate user location to new coordinates
  const recalibrateUserLocation = async (newLocation: MapLocation, recenterMap: boolean = true, zoomLevel?: number) => {
    try {
      setUserLocation(newLocation);
      setCurrentLocation(newLocation);

      if (mapInstanceRef.current) {
        // Update existing marker position or create new one
        if (userMarkerRef.current) {
          // Update existing marker position
          userMarkerRef.current.position = newLocation;
        } else {
          // Create new marker if it doesn't exist
          userMarkerRef.current = await createUserLocationMarker(mapInstanceRef.current, newLocation);
        }

        // Optionally recenter the map to the new location
        if (recenterMap) {
          mapInstanceRef.current.setCenter(newLocation);
          if (zoomLevel) {
            mapInstanceRef.current.setZoom(zoomLevel);
          }
        }

        console.log('‚úÖ User location recalibrated to:', newLocation);
      }
    } catch (error) {
      console.error('Failed to recalibrate user location:', error);
      setLocationError('Failed to update location');
    }
  };

  useEffect(() => {
    if (navigator.geolocation && !isMapLoading) {
      navigator.geolocation.getCurrentPosition(
        async (position) => {
          const location = {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
          };
          setUserLocation(location);
          setCurrentLocation(location);

          if (mapInstanceRef.current) {
            mapInstanceRef.current.setCenter(location);
            mapInstanceRef.current.setZoom(15);

            if (userMarkerRef.current) {
              userMarkerRef.current.map = null;
            }

            try {
              userMarkerRef.current = await createUserLocationMarker(mapInstanceRef.current, location);
            } catch (error) {
              console.error('Failed to create user marker:', error);
            }
          }
        },
        (error) => {
          setLocationError('Unable to get your location. Please enable location services.');
          console.error('Geolocation error:', error);
        }
      );
    }
  }, [isMapLoading, setCurrentLocation]);

  const handleAISearch = async () => {
    if (!searchQuery.trim()) return;

    setIsProcessing(true);
    setLocationError('');

    try {
      const response = await hybridRouter.routeQuery(
        searchQuery,
        destination,
        currentLocation,
        locationConfirmed
      );

      console.log('üéØ Agent response received:', response);
      console.log('üéØ Map actions:', response.mapActions);
      console.log('üéØ App actions:', response.appActions);

      // Handle map actions from AI
      if (response.mapActions && response.mapActions.length > 0) {
        console.log(`üéØ Processing ${response.mapActions.length} map actions`);
        for (const action of response.mapActions) {
          await handleMapAction(action);
        }
      } else {
        console.log('‚ö†Ô∏è No map actions received');
      }

      // Handle app actions (checklists, etc.)
      if (response.appActions && response.appActions.length > 0) {
        console.log('‚úÖ App actions received in MapView:', response.appActions);
        response.appActions.forEach((action: any) => {
          if (action.type === 'checklist' && action.data) {
            console.log('‚úÖ Processing checklist action in MapView:', action.data);
            const checklistData = action.data;
            
            let totalItems = 0;
            
            // Handle new categorized format
            if (checklistData.categories && Array.isArray(checklistData.categories)) {
              console.log(`‚úÖ Processing categorized checklist with ${checklistData.categories.length} categories`);
              checklistData.categories.forEach((categoryObj: any) => {
                const categoryKey = categoryObj.category
                  .toLowerCase()
                  .replace(/\s+/g, '_')
                  .replace(/[^a-z0-9_]/g, '');
                
                if (categoryObj.items && Array.isArray(categoryObj.items)) {
                  console.log(`  Category "${categoryObj.category}": ${categoryObj.items.length} items`);
                  categoryObj.items.forEach((item: any) => {
                    useStore.getState().addChecklistItem({
                      text: item.text,
                      completed: item.checked || false,
                      category: categoryKey
                    });
                    totalItems++;
                  });
                }
              });
              setLocationError(`‚úÖ Added ${totalItems} items across ${checklistData.categories.length} categories to your checklist: "${checklistData.title}". Check the Checklist tab!`);
            }
            // Handle old flat format
            else if (checklistData.items && Array.isArray(checklistData.items)) {
              console.log(`‚úÖ Adding ${checklistData.items.length} checklist items (flat format) to store from MapView`);
              checklistData.items.forEach((item: any, index: number) => {
                const category = mapPriorityToCategory(item.priority);
                console.log(`  Item ${index + 1}: "${item.text}" (category: ${category})`);
                useStore.getState().addChecklistItem({
                  text: item.text,
                  completed: item.checked || false,
                  category: category
                });
              });
              console.log('‚úÖ All items added to store from MapView');
              setLocationError(`‚úÖ Added ${checklistData.items.length} items to your checklist: "${checklistData.title}". Check the Checklist tab!`);
            }
          }
        });
      }

      // Show AI response if no app actions
      if (response.message && (!response.appActions || response.appActions.length === 0)) {
        setLocationError(response.message);
      }
    } catch (error) {
      console.error('AI search error:', error);
      setLocationError('Failed to process your request. Please try again.');
    } finally {
      setIsProcessing(false);
    }
  };

  // Helper function to map priority to category (same as AIGuide)
  const mapPriorityToCategory = (priority: string): 'before' | 'arrival' | 'during' | 'departure' => {
    switch (priority?.toLowerCase()) {
      case 'high':
        return 'before';
      case 'medium':
        return 'during';
      case 'low':
        return 'departure';
      default:
        return 'during';
    }
  };

  const handleMapAction = async (action: any) => {
    if (!mapInstanceRef.current) return;

    console.log('üéØ Handling map action:', action.type, action.data);

    switch (action.type) {
      case 'search':
        // New format: textQuery with optional parameters
        if (action.data.textQuery) {
          console.log('üîç Using Places Text Search API:', action.data.textQuery);
          await performTextSearch(
            action.data.textQuery,
            action.data.locationBias,
            action.data.priceLevels,
            action.data.minRating,
            action.data.openNow,
            action.data.includedType,
            action.data.needsGeocode,
            action.data.geocodeLocation,
            action.data.radius
          );
        }
        // Legacy format: query with coordinates
        else if (action.data.query) {
          if (action.data.latitude && action.data.longitude) {
            await performNearbySearch(
              action.data.query,
              { lat: action.data.latitude, lng: action.data.longitude },
              action.data.radius,
              action.data.priceLevel,
              action.data.minRating,
              action.data.openNow
            );
          } else {
            // Otherwise do geocoding search
            await performSearch(action.data.query);
          }
        }
        break;
      case 'marker':
        if (action.data.location) {
          addMarker(action.data.location, action.data.label);
        }
        break;
      case 'zoom':
        if (action.data.zoom) {
          mapInstanceRef.current.setZoom(action.data.zoom);
        }
        break;
      case 'directions':
      case 'route':  // Support both 'directions' and 'route' type
        if (action.data.origin && action.data.destination) {
          await showDirectionsFromAgent(
            action.data.origin, 
            action.data.destination, 
            action.data.travelMode || action.data.travel_mode || 'TRANSIT'
          );
        }
        break;
    }
  };

  // Helper to parse coordinate string "lat,lng" to MapLocation
  const parseCoordinateString = (coordStr: string): MapLocation | null => {
    try {
      const parts = coordStr.split(',');
      if (parts.length === 2) {
        const lat = parseFloat(parts[0].trim());
        const lng = parseFloat(parts[1].trim());
        if (!isNaN(lat) && !isNaN(lng)) {
          return { lat, lng };
        }
      }
    } catch (e) {
      console.error('Failed to parse coordinates:', coordStr, e);
    }
    return null;
  };

  // Helper to geocode an address to coordinates (with caching and rate limiting)
  const geocodeAddress = async (address: string): Promise<MapLocation | null> => {
    // Check cache first
    const cacheKey = address.toLowerCase().trim();
    if (geocodeCache.current.has(cacheKey)) {
      console.log('üì¶ Using cached geocode result for:', address);
      return geocodeCache.current.get(cacheKey)!;
    }

    // Check if request is already pending
    if (pendingGeocodeRequests.current.has(cacheKey)) {
      console.log('‚è≥ Geocode request already pending for:', address);
      // Wait a bit and check cache again
      await new Promise(resolve => setTimeout(resolve, 500));
      return geocodeCache.current.get(cacheKey) || null;
    }

    // Rate limiting - wait if too soon since last request
    const now = Date.now();
    const timeSinceLastRequest = now - lastGeocodingTime.current;
    if (timeSinceLastRequest < GEOCODING_RATE_LIMIT) {
      const waitTime = GEOCODING_RATE_LIMIT - timeSinceLastRequest;
      console.log(`‚è±Ô∏è Rate limiting: waiting ${waitTime}ms before geocoding`);
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }

    try {
      pendingGeocodeRequests.current.add(cacheKey);
      lastGeocodingTime.current = Date.now();
      console.log('üåç Geocoding address:', address);
      
      const geocoder = new google.maps.Geocoder();
      
      // Determine bias center point
      let biasCenter: { lat: number; lng: number };
      if (userLocation) {
        biasCenter = userLocation;
        console.log('üìç Bias center: User location', biasCenter);
      } else {
        biasCenter = { lat: 1.3521, lng: 103.8198 }; // Singapore center
        console.log('üìç Bias center: Singapore', biasCenter);
      }
      
      // First try: Search with bounds restriction
      const geocodeRequest: google.maps.GeocoderRequest = { 
        address,
        region: 'sg' // Bias toward Singapore region
      };
      
      // Add bounds to prefer results near bias center
      const bounds = new google.maps.Circle({
        center: new google.maps.LatLng(biasCenter.lat, biasCenter.lng),
        radius: 100000 // 100km in meters
      }).getBounds();
      if (bounds) {
        geocodeRequest.bounds = bounds;
      }
      
      const result = await geocoder.geocode(geocodeRequest);
      
      if (result.results && result.results.length > 0) {
        // Calculate distance from each result to bias center
        const resultsWithDistance = result.results.map(r => {
          const loc = r.geometry.location;
          const distance = calculateDistance(
            biasCenter,
            { lat: loc.lat(), lng: loc.lng() }
          ) / 1000; // Convert meters to km
          return { result: r, distance };
        });
        
        // Sort by distance (closest first)
        resultsWithDistance.sort((a, b) => a.distance - b.distance);
        
        // Log all results to see what we got
        console.log('üìä Geocoding results:', resultsWithDistance.map(r => ({
          address: r.result.formatted_address,
          distance: `${r.distance.toFixed(0)} km`,
          lat: r.result.geometry.location.lat(),
          lng: r.result.geometry.location.lng()
        })));
        
        // Pick the closest result
        const closestResult = resultsWithDistance[0].result;
        const location = closestResult.geometry.location;
        const mapLocation = { lat: location.lat(), lng: location.lng() };
        
        // Log which result was chosen
        console.log('‚úÖ Geocoded (closest):', address, '‚Üí', mapLocation, 
                    '(', closestResult.formatted_address, ') -', 
                    resultsWithDistance[0].distance.toFixed(0), 'km from bias center');
        
        // Cache the result
        geocodeCache.current.set(cacheKey, mapLocation);
        
        return mapLocation;
      }
    } catch (e) {
      console.error('‚ùå Geocoding failed for:', address, e);
      // If it's a quota error, increase the rate limit
      if (e instanceof Error && e.message.includes('OVER_QUERY_LIMIT')) {
        console.warn('‚ö†Ô∏è Geocoding quota exceeded. Consider implementing longer delays.');
      }
    } finally {
      pendingGeocodeRequests.current.delete(cacheKey);
    }
    return null;
  };

  // Show directions from agent (handles both coordinate strings and addresses)
  const showDirectionsFromAgent = async (
    origin: string | MapLocation,
    destination: string | MapLocation,
    travelMode: string = 'TRANSIT'
  ) => {
    if (!mapInstanceRef.current) {
      console.error('‚ùå Map instance not available');
      return;
    }

    try {
      setIsProcessing(true);
      console.log('üó∫Ô∏è showDirectionsFromAgent called');
      console.log('  - origin:', origin, typeof origin);
      console.log('  - destination:', destination, typeof destination);
      console.log('  - travelMode:', travelMode);

      // Parse origin
      let originLocation: MapLocation | null = null;
      if (typeof origin === 'string') {
        // Try to parse as coordinates first
        originLocation = parseCoordinateString(origin);
        if (!originLocation) {
          // Geocode as address
          originLocation = await geocodeAddress(origin);
        }
      } else {
        originLocation = origin;
      }

      // Parse destination
      let destLocation: MapLocation | null = null;
      if (typeof destination === 'string') {
        // Try to parse as coordinates first
        destLocation = parseCoordinateString(destination);
        if (!destLocation) {
          // Geocode as address
          destLocation = await geocodeAddress(destination);
        }
      } else {
        destLocation = destination;
      }

      if (!originLocation || !destLocation) {
        setLocationError('Could not determine route locations. Please try again.');
        return;
      }

      console.log('‚úÖ Resolved locations:', { originLocation, destLocation });

      // Now call the original showDirections with resolved coordinates
      await showDirections(originLocation, destLocation, travelMode);
    } catch (error) {
      console.error('Error processing directions:', error);
      setLocationError('Failed to process directions. Please try again.');
    } finally {
      setIsProcessing(false);
    }
  };

  // Helper function to draw colored route segments for transit
  const drawColoredRouteSegments = (route: any) => {
    // Clear existing polylines
    directionsPolylinesRef.current.forEach(polyline => polyline.setMap(null));
    directionsPolylinesRef.current = [];

    if (!route.legs || route.legs.length === 0) return;

    const bounds = new google.maps.LatLngBounds();
    
    route.legs.forEach((leg: any) => {
      if (!leg.steps) return;
      
      leg.steps.forEach((step: any, index: number) => {
        if (!step.polyline?.encodedPolyline) return;
        
        const path = decodePolyline(step.polyline.encodedPolyline);
        let strokeColor = '#666666'; // Default gray
        let strokeWeight = 5;
        let zIndex = 1;
        
        if (step.travelMode === 'WALK') {
          // Walking segments - dotted gray line
          strokeColor = '#888888';
          strokeWeight = 3;
          zIndex = 0; // Lower z-index so transit lines appear on top
        } else if (step.transitDetails) {
          // Transit segments - use line color if available
          strokeColor = step.transitDetails.transitLine?.color || '#4F46E5';
          strokeWeight = 6;
          zIndex = 2;
        }
        
        const polyline = new google.maps.Polyline({
          path,
          geodesic: true,
          strokeColor,
          strokeOpacity: step.travelMode === 'WALK' ? 0.6 : 0.9,
          strokeWeight,
          map: mapInstanceRef.current,
          zIndex,
          ...(step.travelMode === 'WALK' && {
            icons: [{
              icon: {
                path: 'M 0,-1 0,1',
                strokeOpacity: 1,
                scale: 3
              },
              offset: '0',
              repeat: '15px'
            }]
          })
        });
        
        directionsPolylinesRef.current.push(polyline);
        path.forEach(point => bounds.extend(point));
      });
    });
    
    // Fit map to route bounds
    if (mapInstanceRef.current) {
      mapInstanceRef.current.fitBounds(bounds);
    }
  };

  const showDirections = async (
    origin: MapLocation,
    destination: MapLocation,
    travelMode: string = 'TRANSIT'
  ) => {
    if (!mapInstanceRef.current) return;

    try {
      setIsProcessing(true);

      // Clear existing directions polylines
      directionsPolylinesRef.current.forEach(polyline => polyline.setMap(null));
      directionsPolylinesRef.current = [];

      // Clear existing markers
      markersRef.current.forEach(marker => marker.map = null);
      markersRef.current = [];

      // Call Routes API
      const response = await computeRoutes({
        origin: {
          location: {
            latLng: latLngToLocation(origin)
          }
        },
        destination: {
          location: {
            latLng: latLngToLocation(destination)
          }
        },
        travelMode: travelMode as TravelMode,
        computeAlternativeRoutes: false
      });

      if (!response.routes || response.routes.length === 0) {
        setLocationError('No route found between these locations.');
        return;
      }

      // Store all routes and reset selection
      setAllRoutes(response.routes);
      setSelectedRouteIndex(0);
      
      const route = response.routes[0];
      console.log('üó∫Ô∏è Found', response.routes.length, 'route(s)');
      console.log('üó∫Ô∏è Route response:', route);
      console.log('üöá Travel mode:', travelMode);
      console.log('üöá Route legs:', route.legs);

      // Draw route on map - use colored segments for transit, single line for others
      if (travelMode === 'TRANSIT') {
        drawColoredRouteSegments(route);
      } else if (route.polyline.encodedPolyline) {
        // Non-transit: draw single colored polyline
        const path = decodePolyline(route.polyline.encodedPolyline);
        
        const polyline = new google.maps.Polyline({
          path,
          geodesic: true,
          strokeColor: '#4F46E5',
          strokeOpacity: 0.8,
          strokeWeight: 5,
          map: mapInstanceRef.current
        });
        
        directionsPolylinesRef.current.push(polyline);

        // Fit map to route bounds
        const bounds = new google.maps.LatLngBounds();
        path.forEach(point => bounds.extend(point));
        mapInstanceRef.current.fitBounds(bounds);
      }

      // Add markers for origin and destination
      const originMarker = await createMarker(mapInstanceRef.current, origin, 'Origin');
      const destMarker = await createMarker(mapInstanceRef.current, destination, 'Destination');
      
      markersRef.current.push(originMarker, destMarker);

      // Show route info
      const distance = route.localizedValues?.distance?.text || `${(route.distanceMeters / 1000).toFixed(1)} km`;
      const duration = route.localizedValues?.duration?.text || route.duration;
      
      // Extract transit instructions if travel mode is TRANSIT
      if (travelMode === 'TRANSIT' && route.legs && route.legs.length > 0) {
        console.log('üöá Processing TRANSIT mode');
        const leg = route.legs[0];
        const transitSteps: any[] = [];
        
        console.log('üöá Leg steps:', leg.steps);
        
        if (leg.steps) {
          leg.steps.forEach((step: any, index: number) => {
            console.log(`üöá Step ${index + 1}:`, step);
            if (step.transitDetails) {
              // This is a transit step (bus, subway, train, etc.)
              transitSteps.push({
                type: 'transit',
                index: index + 1,
                transitDetails: step.transitDetails,
                distance: step.localizedValues?.distance?.text || `${(step.distanceMeters / 1000).toFixed(1)} km`,
                duration: step.localizedValues?.staticDuration?.text || step.staticDuration
              });
            } else if (step.travelMode === 'WALK') {
              // Walking step
              transitSteps.push({
                type: 'walk',
                index: index + 1,
                distance: step.localizedValues?.distance?.text || `${(step.distanceMeters / 1000).toFixed(1)} km`,
                duration: step.localizedValues?.staticDuration?.text || step.staticDuration,
                instruction: step.navigationInstruction?.instructions || 'Walk'
              });
            }
          });
        }
        
        console.log('üöá Transit steps collected:', transitSteps);
        
        const transitData = {
          steps: transitSteps,
          totalDistance: distance,
          totalDuration: duration,
          fare: route.travelAdvisory?.transitFare
        };
        
        console.log('üöá Setting transit instructions:', transitData);
        setTransitInstructions(transitData);
        
        setLocationError(`Transit route found: ${distance}, ${duration}`);
      } else {
        setTransitInstructions(null);
        setLocationError(`Route found: ${distance}, ${duration}`);
      }
    } catch (error) {
      console.error('Error showing directions:', error);
      setLocationError('Failed to get directions. Please try again.');
    } finally {
      setIsProcessing(false);
    }
  };

  // Function to switch between alternative routes
  const switchToRoute = (routeIndex: number) => {
    if (!allRoutes || routeIndex >= allRoutes.length) return;
    
    setSelectedRouteIndex(routeIndex);
    const route = allRoutes[routeIndex];
    
    // Draw route with colored segments
    drawColoredRouteSegments(route);
    
    // Update transit instructions for the selected route
    const distance = route.localizedValues?.distance?.text || `${(route.distanceMeters / 1000).toFixed(1)} km`;
    const duration = route.localizedValues?.duration?.text || route.duration;
    
    if (route.legs && route.legs.length > 0) {
      const leg = route.legs[0];
      const transitSteps: any[] = [];
      
      if (leg.steps) {
        leg.steps.forEach((step: any, index: number) => {
          if (step.transitDetails) {
            transitSteps.push({
              type: 'transit',
              index: index + 1,
              transitDetails: step.transitDetails,
              distance: step.localizedValues?.distance?.text || `${(step.distanceMeters / 1000).toFixed(1)} km`,
              duration: step.localizedValues?.staticDuration?.text || step.staticDuration
            });
          } else if (step.travelMode === 'WALK') {
            transitSteps.push({
              type: 'walk',
              index: index + 1,
              distance: step.localizedValues?.distance?.text || `${(step.distanceMeters / 1000).toFixed(1)} km`,
              duration: step.localizedValues?.staticDuration?.text || step.staticDuration,
              instruction: step.navigationInstruction?.instructions || 'Walk'
            });
          }
        });
      }
      
      const transitData = {
        steps: transitSteps,
        totalDistance: distance,
        totalDuration: duration,
        fare: route.travelAdvisory?.transitFare
      };
      
      setTransitInstructions(transitData);
      setLocationError(`Route ${routeIndex + 1}: ${distance}, ${duration}`);
    }
  };

  const performSearch = async (query: string) => {
    if (!mapInstanceRef.current) return;

    const geocoder = new google.maps.Geocoder();
    
    try {
      // Determine bias center point
      let biasCenter: { lat: number; lng: number };
      if (userLocation) {
        biasCenter = userLocation;
      } else {
        biasCenter = { lat: 1.3521, lng: 103.8198 }; // Singapore center
      }
      
      // Search with bounds restriction
      const geocodeRequest: google.maps.GeocoderRequest = { 
        address: query,
        region: 'sg'
      };
      
      // Add bounds to prefer results near bias center
      const bounds = new google.maps.Circle({
        center: new google.maps.LatLng(biasCenter.lat, biasCenter.lng),
        radius: 100000 // 100km in meters
      }).getBounds();
      if (bounds) {
        geocodeRequest.bounds = bounds;
      }
      
      const result = await geocoder.geocode(geocodeRequest);
      
      if (result.results && result.results.length > 0) {
        // Calculate distance from each result to bias center and pick closest
        const resultsWithDistance = result.results.map(r => {
          const loc = r.geometry.location;
          const distance = calculateDistance(
            biasCenter,
            { lat: loc.lat(), lng: loc.lng() }
          ) / 1000; // Convert meters to km
          return { result: r, distance };
        });
        
        // Sort by distance (closest first)
        resultsWithDistance.sort((a, b) => a.distance - b.distance);
        
        // Pick the closest result
        const closestResult = resultsWithDistance[0].result;
        const location = closestResult.geometry.location;
        const position = { lat: location.lat(), lng: location.lng() };

        mapInstanceRef.current.setCenter(position);
        mapInstanceRef.current.setZoom(15);

        markersRef.current.forEach(marker => marker.map = null);
        markersRef.current = [];

        createMarker(mapInstanceRef.current, position, query).then(marker => {
          const infoWindow = createInfoWindow(
            `<div style="padding: 8px;">
              <strong>${closestResult.formatted_address}</strong>
            </div>`
          );

          marker.addListener('click', () => {
            infoWindow.open(mapInstanceRef.current!, marker);
          });

          markersRef.current.push(marker);
          infoWindow.open(mapInstanceRef.current, marker);
        }).catch(error => {
          console.error('Failed to create marker:', error);
        });
      }
    } catch (error) {
      console.error('Geocoding error:', error);
      setLocationError('Could not find location. Please try a different search.');
    }
  };

  // Perform nearby search using Places API
  const performNearbySearch = async (
    query: string, 
    location: MapLocation, 
    radius: number = 5000,
    priceLevel?: string,
    minRating?: number,
    openNow?: boolean
  ) => {
    if (!mapInstanceRef.current) return;

    try {
      setIsProcessing(true);
      console.log('üîç Performing nearby search:', { query, location, radius, priceLevel, minRating, openNow });

      // Clear existing markers
      markersRef.current.forEach(marker => marker.map = null);
      markersRef.current = [];

      // Normalize query
      let normalizedQuery = query.toLowerCase().trim();
      
      // Check if query looks like a specific place name (has capital letters or specific words)
      // Indicators of specific place: proper nouns, contains "on", "at", "near", street names
      const specificPlaceIndicators = [
        /^[A-Z]/, // Starts with capital (proper noun)
        /\b(on|at|near|street|road|avenue|lane|drive|blvd|boulevard)\b/i,
        /\d+/, // Contains numbers (addresses)
        query.split(' ').length >= 3, // 3+ words usually means specific place
      ];
      
      const looksLikeSpecificPlace = specificPlaceIndicators.some(indicator => 
        typeof indicator === 'boolean' ? indicator : indicator.test(query)
      );

      // Common PURE category keywords (not part of business names)
      const pureCategoryKeywords = [
        'restaurant', 'hotel', 'cafe', 'coffee', 'bar', 'pub',
        'attraction', 'museum', 'park', 'hospital', 'pharmacy',
        'gas station', 'bank', 'atm', 'mall', 'supermarket',
        'gym', 'spa', 'airport', 'train station', 'bus station'
      ];

      // Check if query is EXACTLY a category (not a business name containing the word)
      const isPureCategory = pureCategoryKeywords.some(keyword => 
        normalizedQuery === keyword || normalizedQuery === keyword + 's'
      );

      // Decide: specific place if it looks specific, OR if it's not a pure category
      const isCategory = isPureCategory && !looksLikeSpecificPlace;

      let response;

      if (!isCategory) {
        // Specific place name - use Text Search
        console.log('üîç Using Text Search for specific place:', query);
        response = await searchText({
          textQuery: query,
          locationBias: {
            circle: {
              center: placesLatLngToLocation(location),
              radius
            }
          },
          maxResultCount: 20
        });
      } else {
        // Category search - use Nearby Search with place types
        console.log('üîç Using Nearby Search for category:', query);
        
        // Remove 's' at end if plural
        if (normalizedQuery.endsWith('s')) {
          normalizedQuery = normalizedQuery.slice(0, -1);
        }
        
        // Map common queries to place types
        const queryMap: Record<string, string> = {
          'restaurant': 'restaurant',
          'hotel': 'lodging',
          'coffee shop': 'cafe',
          'cafe': 'cafe',
          'bar': 'bar',
          'attraction': 'tourist_attraction',
          'museum': 'museum',
          'park': 'park',
          'hospital': 'hospital',
          'pharmacy': 'pharmacy',
          'gas station': 'gas_station',
          'bank': 'bank',
          'atm': 'atm',
          'shopping mall': 'shopping_mall',
          'supermarket': 'supermarket',
          'gym': 'gym',
          'spa': 'spa',
          'airport': 'airport',
          'train station': 'train_station',
          'bus station': 'bus_station',
          'food': 'restaurant',
        };

        const placeType = queryMap[normalizedQuery] || convertLegacyPlaceType(normalizedQuery);
        console.log('üîç Using place type:', placeType);

        response = await searchNearby({
          locationRestriction: {
            circle: {
              center: placesLatLngToLocation(location),
              radius
            }
          },
          includedTypes: [placeType],
          maxResultCount: 20
        });
      }

      if (!response.places || response.places.length === 0) {
        setLocationError(`No ${query} found nearby.`);
        return;
      }

      console.log(`‚úÖ Found ${response.places.length} places (before filtering)`);

      // Client-side filtering (Google API doesn't support all filters server-side)
      let filteredPlaces = response.places;

      // Filter by price level
      if (priceLevel) {
        const priceLevelMap: Record<string, string[]> = {
          'FREE': ['FREE'],
          'INEXPENSIVE': ['FREE', 'INEXPENSIVE'],
          'MODERATE': ['FREE', 'INEXPENSIVE', 'MODERATE'],
          'EXPENSIVE': ['FREE', 'INEXPENSIVE', 'MODERATE', 'EXPENSIVE'],
          'VERY_EXPENSIVE': ['FREE', 'INEXPENSIVE', 'MODERATE', 'EXPENSIVE', 'VERY_EXPENSIVE']
        };
        const allowedLevels = priceLevelMap[priceLevel] || [];
        filteredPlaces = filteredPlaces.filter(place => 
          !place.priceLevel || allowedLevels.includes(place.priceLevel)
        );
        console.log(`üîç After price filter (${priceLevel}): ${filteredPlaces.length} places`);
      }

      // Filter by minimum rating
      if (minRating) {
        filteredPlaces = filteredPlaces.filter(place => 
          place.rating && place.rating >= minRating
        );
        console.log(`üîç After rating filter (>=${minRating}): ${filteredPlaces.length} places`);
      }

      // Filter by open now
      if (openNow) {
        filteredPlaces = filteredPlaces.filter(place => 
          place.regularOpeningHours?.openNow === true
        );
        console.log(`üîç After open_now filter: ${filteredPlaces.length} places`);
      }

      if (filteredPlaces.length === 0) {
        setLocationError(`Found ${response.places.length} places, but none matched your filters (price, rating, or open now).`);
        return;
      }

      console.log(`‚úÖ Displaying ${filteredPlaces.length} places after filters`);

      // Center map on search location
      mapInstanceRef.current.setCenter(location);
      mapInstanceRef.current.setZoom(14);

      // Add markers for each filtered place
      let markersCreated = 0;
      for (const place of filteredPlaces) {
        if (place.location) {
          const placeLocation = locationToLatLng(place.location);
          const marker = await createMarker(
            mapInstanceRef.current,
            placeLocation,
            place.displayName?.text || 'Place'
          );

          // Create info window with place details
          const infoContent = `
            <div style="padding: 8px; max-width: 200px;">
              <strong>${place.displayName?.text || 'Place'}</strong><br/>
              ${place.formattedAddress || ''}<br/>
              ${place.rating ? `‚≠ê ${place.rating}` : ''}
            </div>
          `;
          const infoWindow = createInfoWindow(infoContent);

          marker.addListener('click', () => {
            infoWindow.open(mapInstanceRef.current!, marker);
          });

          markersRef.current.push(marker);
          markersCreated++;
        }
      }

      setLocationError(`Found ${markersCreated} ${query} nearby.`);
    } catch (error) {
      console.error('Nearby search error:', error);
      setLocationError('Failed to search nearby places. Please try again.');
    } finally {
      setIsProcessing(false);
    }
  };

  // Perform text search using Places API (New) Text Search
  const performTextSearch = async (
    textQuery: string,
    locationBias?: any,
    priceLevels?: string[],
    minRating?: number,
    openNow?: boolean,
    includedType?: string,
    needsGeocode?: boolean,
    geocodeLocation?: string,
    radius?: number
  ) => {
    if (!mapInstanceRef.current) return;

    try {
      setIsProcessing(true);
      console.log('üîç Performing text search:', { textQuery, locationBias, priceLevels, minRating, openNow, includedType, needsGeocode, geocodeLocation });

      // Clear existing markers
      markersRef.current.forEach(marker => marker.map = null);
      markersRef.current = [];

      // If needsGeocode is true, geocode the location first
      let finalLocationBias = locationBias;
      let searchCenter: { lat: number; lng: number } | null = null;
      let searchRadius = radius || 5000;
      
      if (needsGeocode && geocodeLocation) {
        console.log('üåç Geocoding location:', geocodeLocation);
        const geocodedLocation = await geocodeAddress(geocodeLocation);
        
        if (geocodedLocation) {
          console.log('‚úÖ Geocoded to:', geocodedLocation);
          searchCenter = geocodedLocation;
          searchRadius = radius || 5000;
          
          // Use locationRestriction instead of locationBias for hard boundary
          finalLocationBias = {
            circle: {
              center: {
                latitude: geocodedLocation.lat,
                longitude: geocodedLocation.lng
              },
              radius: searchRadius
            }
          };
        } else {
          console.warn('‚ö†Ô∏è Failed to geocode location, using textQuery as-is');
          // Fall back to using textQuery without location bias
        }
      } else if (locationBias?.circle?.center) {
        // Extract search center from existing locationBias
        searchCenter = {
          lat: locationBias.circle.center.latitude,
          lng: locationBias.circle.center.longitude
        };
        searchRadius = locationBias.circle.radius || 5000;
      }

      // Build request - use locationRestriction for hard boundary
      const request: any = {
        textQuery,
        maxResultCount: 20
      };

      if (finalLocationBias) {
        // Use locationRestriction instead of locationBias to enforce radius
        request.locationRestriction = finalLocationBias;
      }

      if (priceLevels && priceLevels.length > 0) {
        request.priceLevels = priceLevels;
      }

      if (minRating !== undefined) {
        request.minRating = minRating;
      }

      if (openNow !== undefined) {
        request.openNow = openNow;
      }

      if (includedType) {
        request.includedType = includedType;
      }

      console.log('üì° Text Search request:', request);

      const response = await searchText(request);

      if (!response.places || response.places.length === 0) {
        setLocationError(`No results found for "${textQuery}".`);
        return;
      }

      console.log(`‚úÖ Found ${response.places.length} places via Text Search`);

      // Client-side filtering: Remove places outside the radius (backup enforcement)
      let filteredPlaces = response.places;
      if (searchCenter && searchRadius) {
        filteredPlaces = response.places.filter(place => {
          if (!place.location) return false;
          
          const placeLocation = locationToLatLng(place.location);
          const distance = calculateDistance(searchCenter!, placeLocation);
          const isWithinRadius = distance <= searchRadius;
          
          if (!isWithinRadius) {
            console.log(`üö´ Filtered out: ${place.displayName?.text} (${distance.toFixed(0)}m > ${searchRadius}m)`);
          }
          
          return isWithinRadius;
        });
        
        console.log(`üìç Filtered: ${response.places.length} ‚Üí ${filteredPlaces.length} places within ${searchRadius}m radius`);
      }

      if (filteredPlaces.length === 0) {
        setLocationError(`No results found within ${searchRadius}m for "${textQuery}".`);
        return;
      }

      // Center map on search center or first result
      if (searchCenter) {
        mapInstanceRef.current.setCenter(searchCenter);
        mapInstanceRef.current.setZoom(14);
      } else if (filteredPlaces[0]?.location) {
        const firstLocation = locationToLatLng(filteredPlaces[0].location);
        mapInstanceRef.current.setCenter(firstLocation);
        mapInstanceRef.current.setZoom(14);
      }

      // Add markers for each filtered place
      let markersCreated = 0;
      for (const place of filteredPlaces) {
        if (place.location) {
          const placeLocation = locationToLatLng(place.location);
          const marker = await createMarker(
            mapInstanceRef.current,
            placeLocation,
            place.displayName?.text || 'Place'
          );

          // Create info window with place details
          const infoContent = `
            <div style="padding: 8px; max-width: 200px;">
              <strong>${place.displayName?.text || 'Place'}</strong><br/>
              ${place.formattedAddress || ''}<br/>
              ${place.rating ? `‚≠ê ${place.rating}` : ''}
              ${place.priceLevel ? `<br/>üí∞ ${place.priceLevel.replace('PRICE_LEVEL_', '')}` : ''}
            </div>
          `;
          const infoWindow = createInfoWindow(infoContent);

          marker.addListener('click', () => {
            infoWindow.open(mapInstanceRef.current!, marker);
          });

          markersRef.current.push(marker);
          markersCreated++;
        }
      }

      setLocationError(`‚úÖ Found ${markersCreated} places for "${textQuery}".`);
    } catch (error) {
      console.error('Text search error:', error);
      setLocationError('Failed to search places. Please try again.');
    } finally {
      setIsProcessing(false);
    }
  };

  const addMarker = async (location: { lat: number; lng: number }, label?: string) => {
    if (!mapInstanceRef.current) return;

    try {
      const marker = await createMarker(mapInstanceRef.current, location, label || 'Location');

      const infoWindow = createInfoWindow(
        `<div style="padding: 8px;">
          <strong>${label || 'Location'}</strong>
        </div>`
      );

      marker.addListener('click', () => {
        infoWindow.open(mapInstanceRef.current!, marker);
      });

      markersRef.current.push(marker);
    } catch (error) {
      console.error('Failed to create marker:', error);
    }
  };

  const handleSearch = async () => {
    if (!searchQuery.trim() || !mapInstanceRef.current) return;
    await performSearch(searchQuery);
  };

  const handleNearbySearch = async (type: string) => {
    if (!mapInstanceRef.current || !userLocation) {
      setLocationError('Please enable location services to search nearby places.');
      return;
    }

    setIsProcessing(true);
    setShowNearbyMenu(false);

    try {
      // Clear existing markers
      markersRef.current.forEach(marker => marker.map = null);
      markersRef.current = [];

      // Use new Places API
      const response = await searchNearby({
        includedTypes: [convertLegacyPlaceType(type.toLowerCase())],
        maxResultCount: 10,
        locationRestriction: {
          circle: {
            center: placesLatLngToLocation(userLocation),
            radius: 2000
          }
        },
        rankPreference: 'POPULARITY'
      });

      if (response.places && response.places.length > 0) {
        console.log(`Found ${response.places.length} places`);

        const markerPromises = response.places.map(async (place) => {
          if (place.location && mapInstanceRef.current) {
            const position = locationToLatLng(place.location);

            try {
              const marker = await createMarker(
                mapInstanceRef.current, 
                position, 
                place.displayName?.text || 'Unknown'
              );

              const infoWindow = createInfoWindow(
                `<div style="padding: 8px;">
                  <strong>${place.displayName?.text || 'Unknown'}</strong><br/>
                  ${place.formattedAddress || ''}<br/>
                  ${place.rating ? `‚≠ê ${place.rating} (${place.userRatingCount || 0} reviews)` : ''}
                  ${place.priceLevel ? `<br/>üí∞ ${place.priceLevel}` : ''}
                  ${place.businessStatus === 'OPERATIONAL' ? '<br/>‚úÖ Open' : ''}
                </div>`
              );

              marker.addListener('click', () => {
                infoWindow.open(mapInstanceRef.current!, marker);
              });

              markersRef.current.push(marker);
            } catch (error) {
              console.error('Failed to create marker:', error);
            }
          }
        });

        await Promise.all(markerPromises);
        setLocationError(`Found ${response.places.length} ${type}(s) nearby`);
      } else {
        setLocationError(`No ${type}s found nearby`);
      }
    } catch (error) {
      console.error('Error searching nearby places:', error);
      setLocationError('Failed to search nearby places. Please try again.');
    } finally {
      setIsProcessing(false);
    }
  };

  return (
    <div className="space-y-6">
      <div className="neuro-element p-6">
        <div className="flex items-center justify-between mb-6">
          <h2 className="text-2xl font-bold text-neuro-text">Explore Map</h2>
          {isProcessing && (
            <div className="flex items-center gap-2 text-neuro-accent">
              <Loader2 className="w-5 h-5 animate-spin" strokeWidth={2.5} />
              <span className="text-sm font-medium">Processing...</span>
            </div>
          )}
        </div>
        
        <div className="flex gap-3 mb-4">
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
            placeholder="Search for places..."
            className="flex-1 neuro-input px-4 py-3 text-neuro-text placeholder-neuro-textLight"
            disabled={isProcessing}
          />
          <button
            onClick={handleSearch}
            className="neuro-button px-6 py-3 bg-gradient-to-br from-neuro-accent to-neuro-accentLight"
            aria-label="Search"
            disabled={isProcessing}
          >
            <Search className="w-5 h-5 text-white" strokeWidth={2.5} />
          </button>
        </div>

        <button
          onClick={handleAISearch}
          className="w-full neuro-button p-3 bg-gradient-to-br from-purple-500 to-purple-600 text-white font-medium flex items-center justify-center gap-2 mb-6"
          disabled={isProcessing}
        >
          <Bot className="w-5 h-5" strokeWidth={2.5} />
          Ask AI to Search
        </button>

        {locationError && (
          <div className={`neuro-element-sm p-4 mb-6 ${
            locationError.includes('Failed') || locationError.includes('Unable') 
              ? 'bg-red-50' 
              : 'bg-blue-50'
          }`}>
            <p className={`text-sm ${
              locationError.includes('Failed') || locationError.includes('Unable')
                ? 'text-red-600'
                : 'text-blue-600'
            }`}>
              {locationError}
            </p>
          </div>
        )}

        {userLocation && (
          <div className="neuro-element-sm p-4 mb-6">
            <div className="flex items-center gap-3 mb-3">
              <Navigation className="w-5 h-5 text-neuro-accent" strokeWidth={2.5} />
              <div className="flex-1">
                <p className="text-sm text-neuro-textLight">Your Location</p>
                <p className="text-sm font-semibold text-neuro-text">
                  {userLocation.lat.toFixed(4)}, {userLocation.lng.toFixed(4)}
                </p>
              </div>
            </div>
            
            {/* Quick location presets */}
            <div className="flex gap-2 flex-wrap">
              <button
                onClick={() => recalibrateUserLocation({ lat: 40.7128, lng: -74.0060 }, true, 13)}
                className="text-xs neuro-button px-3 py-1.5 bg-gradient-to-br from-blue-500 to-blue-600 text-white"
                title="Recalibrate to New York"
              >
                üìç NYC
              </button>
              <button
                onClick={() => recalibrateUserLocation({ lat: 51.5074, lng: -0.1278 }, true, 13)}
                className="text-xs neuro-button px-3 py-1.5 bg-gradient-to-br from-blue-500 to-blue-600 text-white"
                title="Recalibrate to London"
              >
                üìç London
              </button>
              <button
                onClick={() => recalibrateUserLocation({ lat: 35.6762, lng: 139.6503 }, true, 13)}
                className="text-xs neuro-button px-3 py-1.5 bg-gradient-to-br from-blue-500 to-blue-600 text-white"
                title="Recalibrate to Tokyo"
              >
                üìç Tokyo
              </button>
              <button
                onClick={() => {
                  if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                      (position) => {
                        recalibrateUserLocation(
                          { lat: position.coords.latitude, lng: position.coords.longitude },
                          true,
                          15
                        );
                      },
                      (error) => {
                        console.error('Geolocation error:', error);
                        setLocationError('Unable to get current GPS location');
                      }
                    );
                  }
                }}
                className="text-xs neuro-button px-3 py-1.5 bg-gradient-to-br from-green-500 to-green-600 text-white"
                title="Reset to current GPS location"
              >
                üéØ GPS
              </button>
            </div>
          </div>
        )}
      </div>

      <div className="neuro-element p-6 relative">
        <div 
          ref={mapRef} 
          className="w-full h-[500px] rounded-2xl overflow-hidden relative"
          style={{ minHeight: '500px' }}
        >
          {/* Floating Control Buttons - Top Right */}
          <div className="absolute top-4 right-4 z-10 flex flex-col gap-2">
            <button
              onClick={() => {
                if (userLocation && mapInstanceRef.current) {
                  mapInstanceRef.current.setCenter(userLocation);
                  mapInstanceRef.current.setZoom(15);
                }
              }}
              className="w-12 h-12 rounded-full bg-white/95 backdrop-blur-sm shadow-lg hover:shadow-xl hover:scale-110 transition-all flex items-center justify-center border border-gray-200"
              disabled={isProcessing}
              title="Center on My Location"
            >
              <Crosshair className="w-5 h-5 text-neuro-accent" strokeWidth={2.5} />
            </button>

            <button
              onClick={() => {
                if (mapInstanceRef.current) {
                  mapInstanceRef.current.setMapTypeId(
                    mapInstanceRef.current.getMapTypeId() === 'roadmap' ? 'satellite' : 'roadmap'
                  );
                }
              }}
              className="w-12 h-12 rounded-full bg-white/95 backdrop-blur-sm shadow-lg hover:shadow-xl hover:scale-110 transition-all flex items-center justify-center border border-gray-200"
              disabled={isProcessing}
              title="Toggle Map Type"
            >
              <Layers className="w-5 h-5 text-gray-700" strokeWidth={2.5} />
            </button>

            <button
              onClick={() => {
                markersRef.current.forEach(marker => marker.map = null);
                markersRef.current = [];
                directionsPolylinesRef.current.forEach(polyline => polyline.setMap(null));
                directionsPolylinesRef.current = [];
                setTransitInstructions(null);
                setAllRoutes([]);
                setSelectedRouteIndex(0);
              }}
              className="w-12 h-12 rounded-full bg-white/95 backdrop-blur-sm shadow-lg hover:shadow-xl hover:scale-110 transition-all flex items-center justify-center border border-gray-200"
              disabled={isProcessing}
              title="Clear Markers & Directions"
            >
              <Trash2 className="w-5 h-5 text-red-500" strokeWidth={2.5} />
            </button>

            <button
              onClick={async () => {
                if (userLocation) {
                  const destLocation = {
                    lat: userLocation.lat + 0.01,
                    lng: userLocation.lng + 0.01
                  };
                  await showDirections(userLocation, destLocation);
                } else {
                  setLocationError('Please enable location services to get directions.');
                }
              }}
              className="w-12 h-12 rounded-full bg-white/95 backdrop-blur-sm shadow-lg hover:shadow-xl hover:scale-110 transition-all flex items-center justify-center border border-gray-200"
              disabled={isProcessing || !userLocation}
              title="Get Directions"
            >
              <Navigation className="w-5 h-5 text-blue-600" strokeWidth={2.5} />
            </button>
          </div>

          {/* Floating Nearby Search Menu - Bottom Left */}
          <div className="absolute bottom-4 left-4 z-10">
            {showNearbyMenu ? (
              <div className="bg-white/95 backdrop-blur-sm rounded-2xl shadow-xl border border-gray-200 p-2 space-y-2">
                <button
                  onClick={() => setShowNearbyMenu(false)}
                  className="w-full flex items-center justify-between px-3 py-2 rounded-lg hover:bg-gray-100 transition-colors"
                >
                  <span className="text-sm font-medium text-gray-700">Close</span>
                  <X className="w-4 h-4 text-gray-500" strokeWidth={2.5} />
                </button>
                <div className="h-px bg-gray-200"></div>
                <button
                  onClick={() => handleNearbySearch('restaurant')}
                  className="w-full flex items-center gap-3 px-3 py-2 rounded-lg hover:bg-gray-100 transition-colors"
                  disabled={isProcessing}
                >
                  <UtensilsCrossed className="w-5 h-5 text-orange-500" strokeWidth={2.5} />
                  <span className="text-sm font-medium text-gray-700">Restaurants</span>
                </button>
                <button
                  onClick={() => handleNearbySearch('lodging')}
                  className="w-full flex items-center gap-3 px-3 py-2 rounded-lg hover:bg-gray-100 transition-colors"
                  disabled={isProcessing}
                >
                  <Hotel className="w-5 h-5 text-blue-500" strokeWidth={2.5} />
                  <span className="text-sm font-medium text-gray-700">Hotels</span>
                </button>
                <button
                  onClick={() => handleNearbySearch('tourist_attraction')}
                  className="w-full flex items-center gap-3 px-3 py-2 rounded-lg hover:bg-gray-100 transition-colors"
                  disabled={isProcessing}
                >
                  <Camera className="w-5 h-5 text-purple-500" strokeWidth={2.5} />
                  <span className="text-sm font-medium text-gray-700">Attractions</span>
                </button>
                <button
                  onClick={() => handleNearbySearch('shopping_mall')}
                  className="w-full flex items-center gap-3 px-3 py-2 rounded-lg hover:bg-gray-100 transition-colors"
                  disabled={isProcessing}
                >
                  <ShoppingBag className="w-5 h-5 text-pink-500" strokeWidth={2.5} />
                  <span className="text-sm font-medium text-gray-700">Shopping</span>
                </button>
              </div>
            ) : (
              <button
                onClick={() => setShowNearbyMenu(true)}
                className="w-12 h-12 rounded-full bg-white/95 backdrop-blur-sm shadow-lg hover:shadow-xl hover:scale-110 transition-all flex items-center justify-center border border-gray-200"
                disabled={isProcessing}
                title="Search Nearby Places"
              >
                <MapPin className="w-5 h-5 text-green-600" strokeWidth={2.5} />
              </button>
            )}
          </div>
        </div>
        
        {/* Loading Overlay */}
        {isMapLoading && (
          <div className="absolute inset-0 bg-gradient-to-br from-neuro-accent/10 to-neuro-accentLight/10 rounded-2xl flex items-center justify-center m-6">
            <div className="text-center">
              <Loader2 className="w-16 h-16 text-neuro-accent mx-auto mb-4 animate-spin" strokeWidth={1.5} />
              <p className="text-neuro-textLight font-medium">Loading Google Maps...</p>
              <p className="text-sm text-neuro-textLight mt-2">Initializing interactive map</p>
            </div>
          </div>
        )}
        
        {/* Error Overlay */}
        {mapError && (
          <div className="absolute inset-0 bg-gradient-to-br from-red-50 to-red-100 rounded-2xl flex items-center justify-center p-6 m-6">
            <div className="text-center">
              <MapPin className="w-16 h-16 text-red-500 mx-auto mb-4" strokeWidth={1.5} />
              <p className="text-red-600 font-semibold mb-2">Map Loading Error</p>
              <p className="text-sm text-red-500">{mapError}</p>
            </div>
          </div>
        )}
      </div>

      {/* Transit Instructions Display */}
      {transitInstructions && (() => {
        console.log('üé® Rendering transit instructions:', transitInstructions);
        return (
          <div className="neuro-element p-6">
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-xl font-bold text-neuro-text flex items-center gap-2">
                üöá Transit Directions
              </h3>
            <button
              onClick={() => {
                setTransitInstructions(null);
                setAllRoutes([]);
                setSelectedRouteIndex(0);
              }}
              className="text-sm text-neuro-textLight hover:text-neuro-text"
            >
              ‚úï Close
            </button>
          </div>

          {/* Route Options Selector */}
          {allRoutes.length > 1 && (
            <div className="mb-4">
              <p className="text-sm text-neuro-textLight mb-2">
                {allRoutes.length} route options available
              </p>
              <div className="flex gap-2 overflow-x-auto pb-2">
                {allRoutes.map((route, index) => {
                  const distance = route.localizedValues?.distance?.text || `${(route.distanceMeters / 1000).toFixed(1)} km`;
                  const duration = route.localizedValues?.duration?.text || route.duration;
                  const isSelected = index === selectedRouteIndex;
                  
                  return (
                    <button
                      key={index}
                      onClick={() => switchToRoute(index)}
                      className={`flex-shrink-0 px-4 py-3 rounded-lg border-2 transition-all ${
                        isSelected
                          ? 'border-neuro-accent bg-blue-50 shadow-md'
                          : 'border-gray-200 hover:border-neuro-accent hover:bg-gray-50'
                      }`}
                    >
                      <div className="text-left">
                        <div className="font-semibold text-sm text-neuro-text">
                          Route {index + 1}
                        </div>
                        <div className="text-xs text-neuro-textLight mt-1">
                          {duration}
                        </div>
                        <div className="text-xs text-neuro-textLight">
                          {distance}
                        </div>
                        {route.travelAdvisory?.transitFare && (
                          <div className="text-xs text-green-600 mt-1 font-semibold">
                            {route.travelAdvisory.transitFare.currencyCode} {route.travelAdvisory.transitFare.units}.
                            {(route.travelAdvisory.transitFare.nanos / 1000000000).toFixed(2).split('.')[1]}
                          </div>
                        )}
                      </div>
                    </button>
                  );
                })}
              </div>
            </div>
          )}

          {/* Route Summary */}
          <div className="bg-blue-50 rounded-lg p-4 mb-4">
            <div className="flex items-center justify-between text-sm">
              <div>
                <span className="font-semibold text-blue-900">Total Duration:</span>
                <span className="ml-2 text-blue-700">{transitInstructions.totalDuration}</span>
              </div>
              <div>
                <span className="font-semibold text-blue-900">Distance:</span>
                <span className="ml-2 text-blue-700">{transitInstructions.totalDistance}</span>
              </div>
              {transitInstructions.fare && (
                <div>
                  <span className="font-semibold text-blue-900">Fare:</span>
                  <span className="ml-2 text-blue-700">
                    {transitInstructions.fare.currencyCode} {transitInstructions.fare.units}.
                    {(transitInstructions.fare.nanos / 1000000000).toFixed(2).split('.')[1]}
                  </span>
                </div>
              )}
            </div>
          </div>

          {/* Step-by-Step Instructions */}
          <div className="space-y-4">
            {transitInstructions.steps.map((step: any, idx: number) => (
              <div key={idx} className="flex gap-4">
                {/* Step Number/Icon */}
                <div className="flex-shrink-0 w-10 h-10 rounded-full bg-neuro-accent text-white flex items-center justify-center font-bold">
                  {step.index}
                </div>

                {/* Step Content */}
                <div className="flex-1">
                  {step.type === 'walk' ? (
                    /* Walking Step */
                    <div className="neuro-element-sm p-4">
                      <div className="flex items-center gap-2 mb-2">
                        <span className="text-2xl">üö∂</span>
                        <span className="font-semibold text-neuro-text">Walk</span>
                        <span className="text-sm text-neuro-textLight">
                          {step.distance} ‚Ä¢ {step.duration}
                        </span>
                      </div>
                      <p className="text-sm text-neuro-textLight">{step.instruction}</p>
                    </div>
                  ) : (
                    /* Transit Step */
                    <div className="neuro-element-sm p-4">
                      <div className="flex items-center gap-2 mb-3">
                        {/* Transit Icon based on vehicle type */}
                        <span className="text-2xl">
                          {step.transitDetails.transitLine?.vehicle?.type === 'SUBWAY' && 'üöá'}
                          {step.transitDetails.transitLine?.vehicle?.type === 'BUS' && 'üöå'}
                          {step.transitDetails.transitLine?.vehicle?.type === 'TRAIN' && 'üöÇ'}
                          {step.transitDetails.transitLine?.vehicle?.type === 'LIGHT_RAIL' && 'üöä'}
                          {step.transitDetails.transitLine?.vehicle?.type === 'RAIL' && 'üöÜ'}
                          {!step.transitDetails.transitLine?.vehicle?.type && 'üöå'}
                        </span>
                        
                        {/* Transit Line Name */}
                        <div className="flex-1">
                          <div className="flex items-center gap-2">
                            {step.transitDetails.transitLine?.nameShort && (
                              <span 
                                className="px-2 py-1 rounded font-bold text-sm"
                                style={{
                                  backgroundColor: step.transitDetails.transitLine?.color || '#666',
                                  color: step.transitDetails.transitLine?.textColor || '#FFF'
                                }}
                              >
                                {step.transitDetails.transitLine.nameShort}
                              </span>
                            )}
                            <span className="font-semibold text-neuro-text">
                              {step.transitDetails.transitLine?.name || 'Transit'}
                            </span>
                          </div>
                          {step.transitDetails.headsign && (
                            <p className="text-sm text-neuro-textLight mt-1">
                              towards {step.transitDetails.headsign}
                            </p>
                          )}
                        </div>
                        
                        <div className="text-sm text-neuro-textLight">
                          {step.duration}
                        </div>
                      </div>

                      {/* Departure Info */}
                      <div className="border-l-2 border-neuro-accent pl-4 space-y-3">
                        <div>
                          <div className="flex items-center gap-2">
                            <span className="text-green-600 font-bold">üìç Board</span>
                            <span className="font-semibold text-neuro-text">
                              {step.transitDetails.stopDetails?.departureStop?.name}
                            </span>
                          </div>
                          {step.transitDetails.localizedValues?.departureTime && (
                            <p className="text-sm text-neuro-textLight ml-6">
                              Depart at {step.transitDetails.localizedValues.departureTime.time?.text}
                            </p>
                          )}
                        </div>

                        {/* Stop Count */}
                        {step.transitDetails.stopCount && (
                          <div className="text-sm text-neuro-textLight ml-6">
                            {step.transitDetails.stopCount} stops
                          </div>
                        )}

                        {/* Arrival Info */}
                        <div>
                          <div className="flex items-center gap-2">
                            <span className="text-red-600 font-bold">üìç Exit</span>
                            <span className="font-semibold text-neuro-text">
                              {step.transitDetails.stopDetails?.arrivalStop?.name}
                            </span>
                          </div>
                          {step.transitDetails.localizedValues?.arrivalTime && (
                            <p className="text-sm text-neuro-textLight ml-6">
                              Arrive at {step.transitDetails.localizedValues.arrivalTime.time?.text}
                            </p>
                          )}
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              </div>
            ))}
          </div>

          {/* Route Summary Footer */}
          <div className="neuro-element p-4 mt-4">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-4">
                <div>
                  <p className="text-sm text-neuro-textLight">Total Duration</p>
                  <p className="text-lg font-bold text-neuro-text">{transitInstructions.duration}</p>
                </div>
                <div className="h-8 w-px bg-neuro-border"></div>
                <div>
                  <p className="text-sm text-neuro-textLight">Total Distance</p>
                  <p className="text-lg font-bold text-neuro-text">{transitInstructions.distance}</p>
                </div>
              </div>
              <button
                onClick={() => setTransitInstructions(null)}
                className="neuro-button-sm"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  };

  return (
    <div className="relative w-full h-screen">
      {/* Map Container */}
      <div 
        ref={mapRef} 
        className="w-full h-full"
        style={{ 
          opacity: isMapLoading ? 0.3 : 1,
          transition: 'opacity 0.3s ease-in-out'
        }}
      />
      
      {/* Loading Overlay */}
      {isMapLoading && (
        <div className="absolute inset-0 flex items-center justify-center bg-neuro-bg/50 backdrop-blur-sm">
          <div className="neuro-element p-6 flex flex-col items-center gap-4">
            <Loader2 className="w-12 h-12 text-neuro-accent animate-spin" />
            <p className="text-neuro-text font-medium">Loading Map...</p>
          </div>
        </div>
      )}
      
      {/* Error Message */}
      {mapError && (
        <div className="absolute top-20 left-1/2 transform -translate-x-1/2 z-20">
          <div className="neuro-element-error px-6 py-4 max-w-md">
            <p className="text-red-600 font-medium">{mapError}</p>
          </div>
        </div>
      )}
      
      {/* Location Error Message */}
      {locationError && (
        <div className="absolute top-20 left-1/2 transform -translate-x-1/2 z-20">
          <div className="neuro-element-error px-6 py-4 max-w-md">
            <p className="text-red-600 font-medium">{locationError}</p>
          </div>
        </div>
      )}

      {/* Search Bar - Moved inside MapView for better integration */}
      <div className="absolute top-4 left-1/2 transform -translate-x-1/2 z-10 w-full max-w-2xl px-4">
        <div className="neuro-element p-4">
          <div className="flex gap-2">
            <div className="relative flex-1">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-neuro-textLight w-5 h-5" />
              <input
                type="text"
                placeholder="Search for places, get directions, or ask anything..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
                disabled={isProcessing || isMapLoading}
                className="w-full pl-10 pr-4 py-3 bg-white/50 border-2 border-neuro-border rounded-xl focus:outline-none focus:border-neuro-accent transition-all disabled:opacity-50 disabled:cursor-not-allowed"
              />
            </div>
            <button
              onClick={handleSearch}
              disabled={isProcessing || isMapLoading || !searchQuery.trim()}
              className="neuro-button px-6 py-3 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isProcessing ? (
                <Loader2 className="w-5 h-5 animate-spin" />
              ) : (
                <Bot className="w-5 h-5" />
              )}
            </button>
          </div>
        </div>
      </div>

      {/* Map Controls - Right Side */}
      <div className="absolute right-4 top-20 z-10 space-y-2">
        {/* Center on User Location */}
        <button
          onClick={centerOnUserLocation}
          disabled={!userLocation}
          className="neuro-button p-3 disabled:opacity-50 disabled:cursor-not-allowed"
          title="Center on my location"
        >
          <Crosshair className="w-5 h-5" />
        </button>
        
        {/* Clear Map */}
        <button
          onClick={clearMap}
          className="neuro-button p-3"
          title="Clear markers and routes"
        >
          <Trash2 className="w-5 h-5" />
        </button>

        {/* Get Directions Button */}
        <div className="pt-2 border-t border-neuro-border/30">
          <button
            onClick={handleDirectionsClick}
            className="neuro-button p-3 hover:scale-105 transition-transform"
            disabled={isProcessing || !userLocation}
            title="Get Directions"
          >
            <Navigation className="w-5 h-5 text-blue-600" strokeWidth={2.5} />
          </button>
        </div>

        {/* Floating Nearby Search Menu - Bottom Left */}
        <div className="absolute bottom-4 left-4 z-10">
          {showNearbyMenu ? (
            <div className="bg-white/95 backdrop-blur-sm rounded-2xl shadow-xl border border-gray-200 p-2 space-y-2">
              <button
                onClick={() => handleNearbySearch('restaurant')}
                className="w-full flex items-center gap-3 px-4 py-3 hover:bg-blue-50 rounded-xl transition-colors"
              >
                <UtensilsCrossed className="w-5 h-5 text-orange-600" />
                <span className="font-medium">Restaurants</span>
              </button>
              <button
                onClick={() => handleNearbySearch('hotel')}
                className="w-full flex items-center gap-3 px-4 py-3 hover:bg-blue-50 rounded-xl transition-colors"
              >
                <Hotel className="w-5 h-5 text-blue-600" />
                <span className="font-medium">Hotels</span>
              </button>
              <button
                onClick={() => handleNearbySearch('tourist_attraction')}
                className="w-full flex items-center gap-3 px-4 py-3 hover:bg-blue-50 rounded-xl transition-colors"
              >
                <Camera className="w-5 h-5 text-green-600" />
                <span className="font-medium">Attractions</span>
              </button>
              <button
                onClick={() => handleNearbySearch('shopping_mall')}
                className="w-full flex items-center gap-3 px-4 py-3 hover:bg-blue-50 rounded-xl transition-colors"
              >
                <ShoppingBag className="w-5 h-5 text-purple-600" />
                <span className="font-medium">Shopping</span>
              </button>
              <button
                onClick={() => setShowNearbyMenu(false)}
                className="w-full flex items-center justify-center gap-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-xl transition-colors mt-2"
              >
                <X className="w-4 h-4" />
                <span className="text-sm">Close</span>
              </button>
            </div>
          ) : (
            <button
              onClick={() => setShowNearbyMenu(true)}
              className="bg-white/95 backdrop-blur-sm rounded-full shadow-lg border border-gray-200 p-4 hover:scale-110 transition-transform"
              title="Search Nearby"
            >
              <Layers className="w-6 h-6 text-blue-600" />
            </button>
          )}
        </div>
      </div>

      {/* Route Selector - Bottom Center */}
      {allRoutes.length > 1 && (
        <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 z-10">
          <div className="neuro-element p-4">
            <div className="flex items-center gap-4">
              <p className="text-sm font-medium text-neuro-text">Select Route:</p>
              <div className="flex gap-2">
                {allRoutes.map((_, index) => (
                  <button
                    key={index}
                    onClick={() => switchToRoute(index)}
                    className={`px-4 py-2 rounded-lg font-medium transition-all ${
                      selectedRouteIndex === index
                        ? 'bg-neuro-accent text-white shadow-lg'
                        : 'bg-white/50 text-neuro-text hover:bg-white/80'
                    }`}
                  >
                    Route {index + 1}
                  </button>
                ))}
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Render Transit Instructions */}
      {renderTransitInstructions()}
    </div>
  );
};
